<script>
  const params = new URLSearchParams(location.search);
  const idRaw = params.get('id');
  if (!idRaw) {
    document.getElementById('chart').textContent = 'Missing player id.';
    throw new Error('no id');
  }

  const PLAYERS_URL = 'data/players.json';
  const HIST_URL    = id => `data/history/${encodeURIComponent(id)}.json`;
  const GAMES_URL   = id => `data/games/${encodeURIComponent(id)}.json`;
  const IS_TOUCH    = window.matchMedia('(pointer: coarse)').matches;

  let RAW = []; // daily series

  function normalise(series, dedupeByDay = false){
    const s = series
      .filter(p => p && p.x && Number.isFinite(p.y))
      .map(p => ({ x: p.x, y: +p.y }))
      .sort((a,b) => new Date(a.x) - new Date(b.x));

    if (!dedupeByDay) return s;

    const out = [];
    let lastKey = null;
    for (const p of s) {
      const d = new Date(p.x);
      const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
      if (key !== lastKey) out.push(p);
      else out[out.length-1] = p; // keep last point that day
      lastKey = key;
    }
    return out;
  }

  function aggregate(series, mode){
    if (mode === 'daily') return normalise(series, true);

    const buckets = Object.create(null);
    for (const p of series) {
      const d = new Date(p.x);
      const key = (mode === 'monthly')
        ? `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`
        : `${d.getFullYear()}`;
      (buckets[key] ||= []).push(p.y);
    }

    const out = Object.keys(buckets).sort().map(k => {
      const ys = buckets[k].filter(Number.isFinite);
      const avg = ys.reduce((a,b)=>a+b,0) / ys.length;
      const x = (k.length === 7) ? `${k}-01` : `${k}-01-01`;
      return { x, y: avg };
    });
    return normalise(out, false);
  }

  function draw(mode){
    const el = document.getElementById('chart');
    if (el.textContent && el.textContent.includes('Loading')) el.textContent = '';

    const data = aggregate(RAW, mode);
    const xs = data.map(p => p.x);
    const ys = data.map(p => p.y).filter(Number.isFinite);
    if (!xs.length || !ys.length) {
      el.textContent = 'No games';
      return;
    }

    const ymin = Math.floor(Math.min(...ys) / 100) * 100;
    const ymax = Math.ceil(Math.max(...ys) / 100) * 100;
    const shapes = [];
    for (let v = ymin; v <= ymax; v += 100) {
      shapes.push({
        type: 'line', xref: 'paper', x0: 0, x1: 1,
        y0: v, y1: v,
        line: { width: 1, color: 'rgba(128,128,128,0.35)' },
        layer: 'below'
      });
    }

    const trace = {
      type: 'scatter',
      x: xs,
      y: ys,
      mode: (mode === 'daily') ? 'lines' : 'lines+markers',
      line: {
        width: 2,
        shape: 'linear',
        color: '#1f77b4'
      },
      marker: (mode === 'daily') ? { size: 0 } : { size: 4 },
      hovertemplate: '%{x}<br>%{y:.0f}<extra></extra>',
      connectgaps: true
    };

    const bg = getComputedStyle(document.body).backgroundColor;
    Plotly.newPlot('chart', [trace], {
      margin:{ l:50, r:20, t:10, b:40 },
      xaxis:{ type:'date' },
      yaxis:{ title:'Rating' },
      paper_bgcolor:bg,
      plot_bgcolor:bg,
      font:{ color:getComputedStyle(document.body).color },
      shapes
    }, {
      staticPlot: IS_TOUCH,
      displayModeBar:false,
      responsive:true
    });
  }

  function renderGamesTable(myName, games) {
    const tbl = document.getElementById('games');
    tbl.innerHTML = '';

    // Header (Date first)
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    for (const h of ['Date','Black','Elo','White','Elo','Result']) {
      const th = document.createElement('th');
      th.textContent = h;
      hr.appendChild(th);
    }
    thead.appendChild(hr);
    tbl.appendChild(thead);

    // Ensure sticky header background matches panel
    const panelBg = getComputedStyle(document.querySelector('.panel')).backgroundColor;
    thead.style.backgroundColor = panelBg;

    // Body (latest first)
    const tbody = document.createElement('tbody');
    games.sort((a,b) => new Date(b.date) - new Date(a.date));

    for (const g of games) {
      const tr = document.createElement('tr');

      const tdDate = document.createElement('td');
      tdDate.textContent = g.date;

      const tdB = document.createElement('td');
      if (g.black === myName) {
        const s = document.createElement('strong');
        s.textContent = g.black;
        tdB.appendChild(s);
      } else {
        tdB.textContent = g.black;
      }

      const tdBE = document.createElement('td');
      tdBE.textContent = Number(g.blackElo).toString();

      const tdW = document.createElement('td');
      if (g.white === myName) {
        const s = document.createElement('strong');
        s.textContent = g.white;
        tdW.appendChild(s);
      } else {
        tdW.textContent = g.white;
      }

      const tdWE = document.createElement('td');
      tdWE.textContent = Number(g.whiteElo).toString();

      const tdR = document.createElement('td');
      tdR.textContent = g.result;
      const iWon = (g.result === '1-0' && g.black === myName) ||
                   (g.result === '0-1' && g.white === myName);
      tdR.className = 'result ' + (iWon ? 'win' : 'loss');

      tr.appendChild(tdDate);
      tr.appendChild(tdB);
      tr.appendChild(tdBE);
      tr.appendChild(tdW);
      tr.appendChild(tdWE);
      tr.appendChild(tdR);
      tbody.appendChild(tr);
    }

    tbl.appendChild(tbody);
  }

  async function load(){
    try {
      const [playersRes, histRes, gamesRes] = await Promise.all([
        fetch(PLAYERS_URL, { cache: 'no-cache' }),
        fetch(HIST_URL(idRaw), { cache: 'no-cache' }),
        fetch(GAMES_URL(idRaw), { cache: 'no-cache' })
      ]);
      if (!playersRes.ok) throw new Error('players.json not found');
      if (!histRes.ok) throw new Error('history not found');

      const players = await playersRes.json();
      const me = players.find(p => p.id === idRaw);
      if (!me) throw new Error('player id not in players.json');
      document.getElementById('pname').textContent = me.name;

      RAW = normalise(
        (await histRes.json()).map(d => ({ x: d.date, y: Number(d.rating) })), true
      );

      if (!RAW.length) {
        document.getElementById('chart').textContent = 'No games';
      } else {
        const initialMode = 'monthly';
        document.getElementById('agg').value = initialMode;
        draw(initialMode);
        document.getElementById('agg').addEventListener('change', e => draw(e.target.value));
      }

      if (gamesRes.ok) {
        const games = await gamesRes.json();
        renderGamesTable(me.name, games);
      } else {
        const tbl = document.getElementById('games');
        tbl.innerHTML = '<tbody><tr><td>No games</td></tr></tbody>';
      }

    } catch (e) {
      console.error(e);
      document.getElementById('chart').textContent = 'Error: ' + e.message;
      const tbl = document.getElementById('games');
      tbl.innerHTML = '<tbody><tr><td>Error loading games</td></tr></tbody>';
    }
  }

  load();
</script>
